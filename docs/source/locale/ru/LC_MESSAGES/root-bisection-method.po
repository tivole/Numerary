# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Kamran Asgarov
# This file is distributed under the same license as the Numerary package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Numerary \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-17 18:15+0400\n"
"PO-Revision-Date: 2020-09-18 22:44+0400\n"
"Last-Translator: Kamran Asgarov <asgarovkamran@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/root-bisection-method.rst:2
msgid "Bisection Method"
msgstr "Метод деления пополам"

#: ../../source/root-bisection-method.rst:5
msgid "Overview"
msgstr "Обзор"

#: ../../source/root-bisection-method.rst:7
msgid ""
"In mathematics, the **bisection method** is a root-finding method that "
"applies to any continuous functions for which one knows two values with "
"opposite signs. The method consists of repeatedly bisecting the interval "
"defined by these values and then selecting the subinterval in which the "
"function changes sign, and therefore must contain a root. It is a very "
"simple and robust method, but it is also relatively slow. Because of "
"this, it is often used to obtain a rough approximation to a solution "
"which is then used as a starting point for more rapidly converging "
"methods. The method is also called the **interval halving method**, the "
"**binary search method**, or the **dichotomy method**."
msgstr ""
"В математике **метод деления пополам** - это метод поиска корней, "
"который применяется к любым непрерывным функциям, для которых известны два "
"значения с противоположными знаками. Метод состоит из многократного деления "
"пополам интервала, определяемого этими значениями, и последующего выбора "
"подинтервала, в котором функция меняет знак и, следовательно, должна "
"содержать корень. Это очень простой и надежный метод, но он также относительно "
"медленный. Из-за этого его часто используют для получения грубого приближения к "
"решению, которое затем используется в качестве отправной точки для более быстро "
"сходящихся методов. Этот метод также называют **методом деления интервала вдвое**, "
"**методом двоичного поиска** или **методом дихотомии**."

#: ../../source/root-bisection-method.rst:15
msgid "The Method"
msgstr "Метод"

#: ../../source/root-bisection-method.rst:17
msgid ""
"The method is applicable for numerically solving the equation :math:`f(x)"
" = 0` for the real variable :math:`x`, where :math:`f` is a continuous "
"function defined on an interval :math:`[a, b]` and where :math:`f(a)` and"
" :math:`f(b)` have opposite signs. In this case :math:`a` and :math:`b` "
"are said to bracket a root since, by the intermediate value theorem, the "
"continuous function :math:`f` must have at least one root in the interval"
" :math:`(a, b)`."
msgstr ""
"Метод применим для численного решения уравнения :math:`f(x) "
"для действительной переменной :math:`x`,, где :math:`f` - непрерывная функция, "
"определенная на интервале :math:`[a, b]`, а :math:`f(a)` и :math:`f(b)` имеют "
"противоположные знаки. . В этом случае говорят, что :math:`a` и :math:`b` "
"заключают в скобки корень, поскольку по теореме о промежуточном "
"значении непрерывная функция :math:`f` должна иметь хотя бы один корень "
"в интервале :math:`(a, b)`."

#: ../../source/root-bisection-method.rst:19
msgid ""
"At each step the method divides the interval in two by computing the "
"midpoint :math:`c = \\frac{a+b}{2}` of the interval and the value of the "
"function :math:`f(c)` at that point. Unless :math:`c` is itself a root "
"(which is very unlikely, but possible) there are now only two "
"possibilities: either :math:`f(a)` and :math:`f(c)` have opposite signs "
"and bracket a root, or :math:`f(c)` and :math:`f(b)` have opposite signs "
"and bracket a root. The method selects the subinterval that is guaranteed"
" to be a bracket as the new interval to be used in the next step. In this"
" way an interval that contains a zero of :math:`f` is reduced in width by"
" *50%* at each step. The process is continued until the interval is "
"sufficiently small."
msgstr ""
"На каждом шаге метод делит интервал на две части, вычисляя среднюю точку "
":math:`c = \\frac{a+b}{2}` интервала и значение функции :math:`f(c)`"
" в этой точке. Если только c не является корнем (что очень маловероятно, "
"но возможно), теперь есть только две возможности: либо "
":math:`f(a)` и :math:`f(c)` имеют противоположные знаки и скобки для"
" корня, либо :math:`f(c)` и :math:`f(b)` иметь противоположные знаки"
" и заключать в скобки корень. Метод выбирает подинтервал, который гарантированно "
"является скобкой, в качестве нового интервала, который будет использоваться "
"на следующем шаге. Таким образом, интервал, содержащий ноль :math:`f`, "
"уменьшается по ширине на *50%* на каждом шаге. Процесс продолжается до тех пор, "
"пока интервал не станет достаточно малым."

#: ../../source/root-bisection-method.rst:21
msgid ""
"Explicitly, if :math:`f(a)` and :math:`f(c)` have opposite signs, then "
"the method sets :math:`c` as the new value for :math:`b`, and if "
":math:`f(b)` and :math:`f(c)` have opposite signs then the method sets "
":math:`c` as the new :math:`a`. (If :math:`f(c)=0` then :math:`c` may be "
"taken as the solution and the process stops.) In both cases, the new "
":math:`f(a)` and :math:`f(b)` have opposite signs, so the method is "
"applicable to this smaller interval."
msgstr ""
"Явно, если :math:`f(a)` и :math:`f(c)` имеют противоположные знаки, "
"тогда метод устанавливает :math:`c` как новое значение для :math:`b`, а если "
":math:`f(b)` и :math:`f(c)` имеют противоположные знаки, то метод "
"устанавливает c как новое значение а. (Если :math:`f(c) = 0`, "
"то c может быть принято как решение, и процесс останавливается.) "
"В обоих случаях новые :math:`f(a)` и :math:`f(b)` имеют противоположные знаки, "
"поэтому метод применим к этому меньшему интервалу ."

#: ../../source/root-bisection-method.rst:25
msgid "Iteration Tasks"
msgstr "Итерационные задачи"

#: ../../source/root-bisection-method.rst:27
msgid ""
"Calculate :math:`c`, the midpoint of the interval, "
":math:`c=\\frac{a+b}{2}`."
msgstr ""
"Вычислите :math:`c`, середину интервала, "
":math:`c=\\frac{a+b}{2}`."

#: ../../source/root-bisection-method.rst:28
msgid "Calculate the function value at the midpoint, :math:`f(c)`."
msgstr "Вычислить значение функции в средней точке, :math:`f(c)`."

#: ../../source/root-bisection-method.rst:29
msgid ""
"If convergence is satisfactory (that is, :math:`c-a` is sufficiently "
"small, or :math:`|f(c)|` is sufficiently small), return :math:`c` and "
"stop iterating."
msgstr ""
"Если сходимость удовлетворительная (т. е. "
":math:`c-a` достаточно мало или :math:`|f(c)|` достаточно "
"мало), верните c и прекратите повторение."

#: ../../source/root-bisection-method.rst:30
msgid ""
"Examine the sign of :math:`f(c)` and replace either :math:`(a, f(a))` or "
":math:`(b, f(b))` with :math:`(c, f(c))` so that there is a zero crossing"
" within the new interval."
msgstr ""
"Изучите знак :math:`f(c)` и замените :math:`(a, f(a))`"
" или :math:`(b, f(b))` на :math:`(c, f(c))` так, "
"чтобы в новом интервале было пересечение нуля."

#: ../../source/root-bisection-method.rst:34
msgid "Usage"
msgstr "Использование"

#: ../../source/root-bisection-method.rst:36
msgid "Imagine that we want to find the root of the following function:"
msgstr "Представьте, что мы хотим найти корень следующей функции:"

#: ../../source/root-bisection-method.rst:38
msgid ""
"\\begin{equation}\n"
"    f(x) = \\sin{(x)}, x \\in [-1, 1]\n"
"\\end{equation}"
msgstr ""
"\\begin{equation}\n"
"    f(x) = \\sin{(x)}, x \\in [-1, 1]\n"
"\\end{equation}"

#: ../../source/root-bisection-method.rst:45
msgid "Then the code will look like this:"
msgstr "Тогда код будет выглядеть так:"

